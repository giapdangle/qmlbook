<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>9. Shader Effects &mdash; Qt5 Cadaques Book v2014-12</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootswatch-3.2.0/sandstone/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2014-12',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.2.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="Qt5 Cadaques Book v2014-12" href="../index.html" />
    <link rel="next" title="10. Multimedia" href="../ch10/index.html" />
    <link rel="prev" title="8. Particle Simulations" href="../ch08/index.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          QmlBook</a>
        <span class="navbar-text navbar-version pull-left"><b>2014-12</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Chapters <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../ch01/index.html">1. Meet Qt 5</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch02/index.html">2. Get Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch03/index.html">3. Qt Creator IDE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch04/index.html">4. Quick Starter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch05/index.html">5. Fluid Elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch06/index.html">6. Model-View-Delegate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch07/index.html">7. Canvas Element</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch08/index.html">8. Particle Simulations</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">9. Shader Effects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch10/index.html">10. Multimedia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch11/index.html">11. Networking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch12/index.html">12. Storage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch13/index.html">13. Dynamic QML</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch14/index.html">14. JavaScript</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">9. Shader Effects</a><ul>
<li><a class="reference internal" href="#opengl-shaders">9.1. OpenGL Shaders</a></li>
<li><a class="reference internal" href="#shader-elements">9.2. Shader Elements</a></li>
<li><a class="reference internal" href="#fragment-shaders">9.3. Fragment Shaders</a></li>
<li><a class="reference internal" href="#wave-effect">9.4. Wave Effect</a></li>
<li><a class="reference internal" href="#vertex-shader">9.5. Vertex Shader</a></li>
<li><a class="reference internal" href="#curtain-effect">9.6. Curtain Effect</a></li>
<li><a class="reference internal" href="#qt-graphicseffect-library">9.7. Qt GraphicsEffect Library</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="../ch08/index.html" title="Previous Chapter: 8. Particle Simulations"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; 8. Particle Simu...</span>
    </a>
  </li>
  <li>
    <a href="../ch10/index.html" title="Next Chapter: 10. Multimedia"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">10. Multimedia &raquo;</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li><a class="reference internal" href="#">9. Shader Effects</a><ul>
<li><a class="reference internal" href="#opengl-shaders">9.1. OpenGL Shaders</a></li>
<li><a class="reference internal" href="#shader-elements">9.2. Shader Elements</a></li>
<li><a class="reference internal" href="#fragment-shaders">9.3. Fragment Shaders</a></li>
<li><a class="reference internal" href="#wave-effect">9.4. Wave Effect</a></li>
<li><a class="reference internal" href="#vertex-shader">9.5. Vertex Shader</a></li>
<li><a class="reference internal" href="#curtain-effect">9.6. Curtain Effect</a></li>
<li><a class="reference internal" href="#qt-graphicseffect-library">9.7. Qt GraphicsEffect Library</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    <div class="col-md-9">
      
  <div class="section" id="shader-effects">
<h1>9. Shader Effects<a class="headerlink" href="#shader-effects" title="Permalink to this headline">Â¶</a></h1>
<p><em>Section author: <a class="reference external" href="https://github.com/jryannel">jryannel</a></em></p>
<div class="admonition issues">Issues: <a href="https://github.com/qmlbook/qmlbook/issues/new?body=back-link%3A+ch09%2Findex.html%23shader-effects&labels=ch09">Create</a> | <a href="https://github.com/qmlbook/qmlbook/issues?labels=ch09&page=1&state=open">View</a></div><div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Last Build: December 22, 2014 at 17:41 CET</p>
<p class="last">The source code for this chapter can be found in the <a class="reference external" href="../assets">assets folder</a>.</p>
</div>
<div class="topic">
<p class="topic-title first">Objective</p>
<ul class="simple">
<li><a class="reference external" href="http://labs.qt.nokia.com/2012/02/02/qt-graphical-effects-in-qt-labs/">http://labs.qt.nokia.com/2012/02/02/qt-graphical-effects-in-qt-labs/</a></li>
<li><a class="reference external" href="http://labs.qt.nokia.com/2011/05/03/qml-shadereffectitem-on-qgraphicsview/">http://labs.qt.nokia.com/2011/05/03/qml-shadereffectitem-on-qgraphicsview/</a></li>
<li><a class="reference external" href="http://qt-project.org/doc/qt-4.8/declarative-shadereffects.html">http://qt-project.org/doc/qt-4.8/declarative-shadereffects.html</a></li>
<li><a class="reference external" href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.6.clean.pdf">http://www.opengl.org/registry/doc/GLSLangSpec.4.20.6.clean.pdf</a></li>
<li><a class="reference external" href="http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf">http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf</a></li>
<li><a class="reference external" href="http://www.lighthouse3d.com/opengl/glsl/">http://www.lighthouse3d.com/opengl/glsl/</a></li>
<li><a class="reference external" href="http://wiki.delphigl.com/index.php/Tutorial_glsl">http://wiki.delphigl.com/index.php/Tutorial_glsl</a></li>
<li><a class="reference external" href="http://qt-project.org/doc/qt-5/qtquick-shaders.html">Qt5Doc qtquick-shaders</a></li>
</ul>
<p>Give a short introduction to shader effects and then present the shader effects and their use.</p>
</div>
<p>Shaders allows us to create awesome rendering effects on top to the SceneGraph API leveraging directly the power of OpenGL running on the GPU. Shaders are implemented using the ShaderEffect and ShaderEffectSource elements. The shader algorithm itself is implemented using the OpenGL Shading Language.</p>
<p>Practically it means you mix QML code with shader code. On execution will the shader code be sent over to the GPU and compiled and executed on the GPU. The shader QML elements allow you to interact through properties with the OpenGL shader implementation.</p>
<p>Let&#8217;s first have a look what OpenGL shaders are.</p>
<div class="section" id="opengl-shaders">
<h2>9.1. OpenGL Shaders<a class="headerlink" href="#opengl-shaders" title="Permalink to this headline">Â¶</a></h2>
<div class="admonition issues">Issues: <a href="https://github.com/qmlbook/qmlbook/issues/new?body=back-link%3A+ch09%2Findex.html%23opengl-shaders&labels=ch09">Create</a> | <a href="https://github.com/qmlbook/qmlbook/issues?labels=ch09&page=1&state=open">View</a></div><p>OpenGL uses a rendering pipeline split into stages. A simplified OpenGL pipeline would contain a vertex and fragment shader.</p>
<img alt="../_images/openglpipeline.png" src="../_images/openglpipeline.png" />
<p>The vertex shader receives vertex data and must assign it to the <em>gl_Position</em> at the end of the routine. In the next stage the vertexes are clipped, transformed and rasterized for pixel output. From there the fragments (pixels) arrive in the fragment shader and can further be manipulated and the resulting color needs to be assigned to <em>gl_FragColor</em>. The vertex shader is called for each corner point of your polygon (vertex = point in 3D) and is responsible of any 3D manipulation of these points. The fragment (fragment = pixel) shader is called for each pixel and determines the color of that pixel.</p>
</div>
<div class="section" id="shader-elements">
<h2>9.2. Shader Elements<a class="headerlink" href="#shader-elements" title="Permalink to this headline">Â¶</a></h2>
<div class="admonition issues">Issues: <a href="https://github.com/qmlbook/qmlbook/issues/new?body=back-link%3A+ch09%2Findex.html%23shader-elements&labels=ch09">Create</a> | <a href="https://github.com/qmlbook/qmlbook/issues?labels=ch09&page=1&state=open">View</a></div><p>For programing shaders Qt Quick provides two elements. The ShaderEffectSource and the ShaderEffect. The shader effect applies custom shaders and the shader effect source renders a QML item into a texture and renders it. As shader effect can apply a custom shaders to it&#8217;s rectangular shape and can use sources for the shader operation. A source can be an image, which is used as a texture or a shader effect source.</p>
<p>The default shader uses the source and renders it unmodified.</p>
<div class="highlight-qml"><div class="highlight"><pre><span class="kr">import</span> <span class="nx">QtQuick</span> <span class="mf">2.0</span>

<span class="nx">Rectangle</span> <span class="p">{</span>
    <span class="k">width:</span> <span class="mi">480</span><span class="p">;</span> <span class="k">height:</span> <span class="mi">240</span>
    <span class="k">color:</span> <span class="s1">&#39;#1e1e1e&#39;</span>

    <span class="nx">Row</span> <span class="p">{</span>
        <span class="k">anchors.centerIn:</span> <span class="nx">parent</span>
        <span class="k">spacing:</span> <span class="mi">20</span>
        <span class="nx">Image</span> <span class="p">{</span>
            <span class="kd">id: sourceImage</span>
            <span class="k">width:</span> <span class="mi">80</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
            <span class="k">source:</span> <span class="s1">&#39;assets/tulips.jpg&#39;</span>
        <span class="p">}</span>
        <span class="nx">ShaderEffect</span> <span class="p">{</span>
            <span class="kd">id: effect</span>
            <span class="k">width:</span> <span class="mi">80</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
            <span class="nx">property</span> <span class="nx">variant</span> <span class="k">source:</span> <span class="nx">sourceImage</span>
        <span class="p">}</span>
        <span class="nx">ShaderEffect</span> <span class="p">{</span>
            <span class="kd">id: effect2</span>
            <span class="k">width:</span> <span class="mi">80</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
            <span class="c1">// the source where the effect shall be applied to</span>
            <span class="nx">property</span> <span class="nx">variant</span> <span class="k">source:</span> <span class="nx">sourceImage</span>
            <span class="c1">// default vertex shader code</span>
            <span class="k">vertexShader:</span> <span class="s2">&quot;</span>
<span class="s2">                uniform highp mat4 qt_Matrix;</span>
<span class="s2">                attribute highp vec4 qt_Vertex;</span>
<span class="s2">                attribute highp vec2 qt_MultiTexCoord0;</span>
<span class="s2">                varying highp vec2 qt_TexCoord0;</span>
<span class="s2">                void main() {</span>
<span class="s2">                    qt_TexCoord0 = qt_MultiTexCoord0;</span>
<span class="s2">                    gl_Position = qt_Matrix * qt_Vertex;</span>
<span class="s2">                }&quot;</span>
            <span class="c1">// default fragment shader code</span>
            <span class="k">fragmentShader:</span> <span class="s2">&quot;</span>
<span class="s2">                varying highp vec2 qt_TexCoord0;</span>
<span class="s2">                uniform sampler2D source;</span>
<span class="s2">                uniform lowp float qt_Opacity;</span>
<span class="s2">                void main() {</span>
<span class="s2">                    gl_FragColor = texture2D(source, qt_TexCoord0) * qt_Opacity;</span>
<span class="s2">                }&quot;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<img alt="../_images/defaultshader.png" src="../_images/defaultshader.png" />
<p>In the above example we have a row of 3 images. The first is the real image. The second is rendered using the default shader and the third is rendered using the default shader code for the fragment and vertex extracted from the Qt5 source code.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you don&#8217;t want to see the source image and only the effected image you can set the <em>Image</em> to invisible (<tt class="docutils literal"><span class="pre">visible</span> <span class="pre">:</span> <span class="pre">false</span></tt>). The shader effects will still use the image data just the <em>Image</em> element will not be rendered.</p>
</div>
<p>Let&#8217;s have a closer look at the shader code.</p>
<div class="highlight-js"><div class="highlight"><pre><span class="nx">vertexShader</span><span class="o">:</span> <span class="s2">&quot;</span>
<span class="s2">    uniform highp mat4 qt_Matrix;</span>
<span class="s2">    attribute highp vec4 qt_Vertex;</span>
<span class="s2">    attribute highp vec2 qt_MultiTexCoord0;</span>
<span class="s2">    varying highp vec2 qt_TexCoord0;</span>
<span class="s2">    void main() {</span>
<span class="s2">        qt_TexCoord0 = qt_MultiTexCoord0;</span>
<span class="s2">        gl_Position = qt_Matrix * qt_Vertex;</span>
<span class="s2">    }&quot;</span>
</pre></div>
</div>
<p>Both shaders are from the Qt side a string bound to the <em>vertexShader</em> and <em>fragmentShader</em> property. Every shader code has to have a <em>main() { ... }</em> function, which is executed by the GPU. Variable starting with <em>qt_</em> are provided by default by Qt already.</p>
<p>Here a short rundown on the variables:</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>uniform</td>
<td>value does not change during processing</td>
</tr>
<tr class="row-even"><td>attribute</td>
<td>linkage to external data</td>
</tr>
<tr class="row-odd"><td>varying</td>
<td>shared value between shaders</td>
</tr>
<tr class="row-even"><td>highp</td>
<td>high precision value</td>
</tr>
<tr class="row-odd"><td>lowp</td>
<td>low precision value</td>
</tr>
<tr class="row-even"><td>mat4</td>
<td>4x4 float matrix</td>
</tr>
<tr class="row-odd"><td>vec2</td>
<td>2=dim float vector</td>
</tr>
<tr class="row-even"><td>sampler2D</td>
<td>2D texture</td>
</tr>
<tr class="row-odd"><td>float</td>
<td>floating scalar</td>
</tr>
</tbody>
</table>
<p>A better reference is the <a class="reference external" href="http://www.khronos.org/opengles/sdk/docs/reference_cards/OpenGL-ES-2_0-Reference-card.pdf">OpenGL ES 2.0 API Quick Reference Card</a></p>
<p>Now we might be better able to understand what the variable are:</p>
<ul class="simple">
<li>qt_Matrix: model-view-projection matrix</li>
<li>qt_Vertex: current vertex position</li>
<li>qt_MultiTexCoord0: texture coordinate</li>
<li>qt_TexCoord0: shared texture coordinate</li>
</ul>
<p>So we have available the projection matrix, the current vertex and the texture coordinate. The texture coordinate relates to the texture given as source. In the <em>main()</em> function we store the texture coordinate for later use in the fragment shader. Every vertex shader need to assign the <em>gl_Position</em> this is done using here by multiplying the project matrix with the vertex, our point in 3D.</p>
<p>The fragment shader receives our texture coordinate from the vertex shader and also the texture from our QML source property. It shall be noted how easy it is to pass variable between the shader code and QML. Beautiful. Additional we have the opacity of the shader effect available as <em>qt_Opacity</em>. Every fragment shader needs to assign the <em>gl_FragColor</em> variable, this is done in the default shader code by picking the pixel from the source texture and multiplying it with the opacity.</p>
<div class="highlight-js"><div class="highlight"><pre><span class="nx">fragmentShader</span><span class="o">:</span> <span class="s2">&quot;</span>
<span class="s2">    varying highp vec2 qt_TexCoord0;</span>
<span class="s2">    uniform sampler2D source;</span>
<span class="s2">    uniform lowp float qt_Opacity;</span>
<span class="s2">    void main() {</span>
<span class="s2">        gl_FragColor = texture2D(source, qt_TexCoord0) * qt_Opacity;</span>
<span class="s2">    }&quot;</span>
</pre></div>
</div>
<p>During the next examples we will playing around with some simple shader mechanics. First we concentrate on the fragment shader and then we will come back to the vertex shader.</p>
</div>
<div class="section" id="fragment-shaders">
<h2>9.3. Fragment Shaders<a class="headerlink" href="#fragment-shaders" title="Permalink to this headline">Â¶</a></h2>
<div class="admonition issues">Issues: <a href="https://github.com/qmlbook/qmlbook/issues/new?body=back-link%3A+ch09%2Findex.html%23fragment-shaders&labels=ch09">Create</a> | <a href="https://github.com/qmlbook/qmlbook/issues?labels=ch09&page=1&state=open">View</a></div><p>The fragment shader is called for every pixel to be rendered. We will develop a small red lens, which will increase the red color channel value of the image.</p>
<p class="rubric">Setting up the scene</p>
<p>First we setup our scene, with a grid centered in the field and our source image be displayed.</p>
<div class="highlight-qml"><div class="highlight"><pre><span class="kr">import</span> <span class="nx">QtQuick</span> <span class="mf">2.0</span>

<span class="nx">Rectangle</span> <span class="p">{</span>
    <span class="k">width:</span> <span class="mi">480</span><span class="p">;</span> <span class="k">height:</span> <span class="mi">240</span>
    <span class="k">color:</span> <span class="s1">&#39;#1e1e1e&#39;</span>

    <span class="nx">Grid</span> <span class="p">{</span>
        <span class="k">anchors.centerIn:</span> <span class="nx">parent</span>
        <span class="k">spacing:</span> <span class="mi">20</span>
        <span class="k">rows:</span> <span class="mi">2</span><span class="p">;</span> <span class="k">columns:</span> <span class="mi">4</span>
        <span class="nx">Image</span> <span class="p">{</span>
            <span class="kd">id: sourceImage</span>
            <span class="k">width:</span> <span class="mi">80</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
            <span class="k">source:</span> <span class="s1">&#39;assets/tulips.jpg&#39;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<img alt="../_images/redlense1.png" src="../_images/redlense1.png" />
<p class="rubric">A red shader</p>
<p>Next we will add a shader, which displays a red rectangle. As we don&#8217;t need the texture for this we remove the texture from the vertex shader.</p>
<div class="highlight-qml"><div class="highlight"><pre>            <span class="k">vertexShader:</span> <span class="s2">&quot;</span>
<span class="s2">                uniform highp mat4 qt_Matrix;</span>
<span class="s2">                attribute highp vec4 qt_Vertex;</span>
<span class="s2">                void main() {</span>
<span class="s2">                    gl_Position = qt_Matrix * qt_Vertex;</span>
<span class="s2">                }&quot;</span>
            <span class="k">fragmentShader:</span> <span class="s2">&quot;</span>
<span class="s2">                uniform lowp float qt_Opacity;</span>
<span class="s2">                void main() {</span>
<span class="s2">                    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0) * qt_Opacity;</span>
<span class="s2">                }&quot;</span>
</pre></div>
</div>
<p>In the fragment shader we simple assign a <em>vec4(1.0, 0.0, 0.0, 1.0)</em> which represents a red color with full opacity (alpha=1.0) to the <em>gl_FragColor</em>.</p>
<img alt="../_images/redlense2.png" src="../_images/redlense2.png" />
<p class="rubric">A red shader with texture</p>
<p>Now we want to apply the red color to each texture pixel. For this we need the texture back in the vertex shader. As we don&#8217;t do anything else in the vertex shader the default vertex shader is enough for us.</p>
<div class="highlight-qml"><div class="highlight"><pre>        <span class="nx">ShaderEffect</span> <span class="p">{</span>
            <span class="kd">id: effect2</span>
            <span class="k">width:</span> <span class="mi">80</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
            <span class="nx">property</span> <span class="nx">variant</span> <span class="k">source:</span> <span class="nx">sourceImage</span>
            <span class="k">visible:</span> <span class="nx">root</span><span class="p">.</span><span class="nx">step</span><span class="o">&gt;</span><span class="mi">1</span>
            <span class="k">fragmentShader:</span> <span class="s2">&quot;</span>
<span class="s2">                varying highp vec2 qt_TexCoord0;</span>
<span class="s2">                uniform sampler2D source;</span>
<span class="s2">                uniform lowp float qt_Opacity;</span>
<span class="s2">                void main() {</span>
<span class="s2">                    gl_FragColor = texture2D(source, qt_TexCoord0) * vec4(1.0, 0.0, 0.0, 1.0) * qt_Opacity;</span>
<span class="s2">                }&quot;</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>The full shader contains now back our image source as variant property and we have left out the vertex shader, which if not specified is the default vertex shader.</p>
<p>In the fragment shader we pick the texture fragment <em>texture2D(source, qt_TexCoord0)</em> and apply the red color to it.</p>
<img alt="../_images/redlense3.png" src="../_images/redlense3.png" />
<p class="rubric">The red channel property</p>
<p>It&#8217;s not really nice to hard code the red channel value, so we would like to control the value from the QML side. For this we add a <em>redChannel</em> property to our shader effect and also declare a <em>uniform lowp float redChannel</em> inside our fragment shader. That&#8217;s all to make a value from the shader code available to the QML side. Very simple.</p>
<div class="highlight-qml"><div class="highlight"><pre>        <span class="nx">ShaderEffect</span> <span class="p">{</span>
            <span class="kd">id: effect3</span>
            <span class="k">width:</span> <span class="mi">80</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
            <span class="nx">property</span> <span class="nx">variant</span> <span class="k">source:</span> <span class="nx">sourceImage</span>
            <span class="nx">property</span> <span class="nx">real</span> <span class="k">redChannel:</span> <span class="mf">0.3</span>
            <span class="k">visible:</span> <span class="nx">root</span><span class="p">.</span><span class="nx">step</span><span class="o">&gt;</span><span class="mi">2</span>
            <span class="k">fragmentShader:</span> <span class="s2">&quot;</span>
<span class="s2">                varying highp vec2 qt_TexCoord0;</span>
<span class="s2">                uniform sampler2D source;</span>
<span class="s2">                uniform lowp float qt_Opacity;</span>
<span class="s2">                uniform lowp float redChannel;</span>
<span class="s2">                void main() {</span>
<span class="s2">                    gl_FragColor = texture2D(source, qt_TexCoord0) * vec4(redChannel, 1.0, 1.0, 1.0) * qt_Opacity;</span>
<span class="s2">                }&quot;</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>To make the lens really a lens, we change the <em>vec4</em> color to be <em>vec4(redChannel, 1.0, 1.0, 1.0)</em> so that the other colors are multiplied by 1.0 and only the red portion is multiplied by our <em>redChannel</em> variable.</p>
<img alt="../_images/redlense4.png" src="../_images/redlense4.png" />
<p class="rubric">The red channel animated</p>
<p>As the <em>redChannel</em> property is just a normal property it can also be animated as all properties in QML. So we can use QML properties to animate values on the the GPU to influence our shaders. How cool is that!</p>
<div class="highlight-qml"><div class="highlight"><pre>        <span class="nx">ShaderEffect</span> <span class="p">{</span>
            <span class="kd">id: effect4</span>
            <span class="k">width:</span> <span class="mi">80</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
            <span class="nx">property</span> <span class="nx">variant</span> <span class="k">source:</span> <span class="nx">sourceImage</span>
            <span class="nx">property</span> <span class="nx">real</span> <span class="k">redChannel:</span> <span class="mf">0.3</span>
            <span class="k">visible:</span> <span class="nx">root</span><span class="p">.</span><span class="nx">step</span><span class="o">&gt;</span><span class="mi">3</span>
            <span class="nx">NumberAnimation</span> <span class="nx">on</span> <span class="nx">redChannel</span> <span class="p">{</span>
                <span class="k">from:</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">to:</span> <span class="mf">1.0</span><span class="p">;</span> <span class="k">loops:</span> <span class="nx">Animation</span><span class="p">.</span><span class="nx">Infinite</span><span class="p">;</span> <span class="k">duration:</span> <span class="mi">4000</span>
            <span class="p">}</span>

            <span class="k">fragmentShader:</span> <span class="s2">&quot;</span>
<span class="s2">                varying highp vec2 qt_TexCoord0;</span>
<span class="s2">                uniform sampler2D source;</span>
<span class="s2">                uniform lowp float qt_Opacity;</span>
<span class="s2">                uniform lowp float redChannel;</span>
<span class="s2">                void main() {</span>
<span class="s2">                    gl_FragColor = texture2D(source, qt_TexCoord0) * vec4(redChannel, 1.0, 1.0, 1.0) * qt_Opacity;</span>
<span class="s2">                }&quot;</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>Here the final result.</p>
<img alt="../_images/redlense5.png" src="../_images/redlense5.png" />
<p>The shader effect on the 2nd row is animated from 0.0 to 1.0 with a duration of 4 seconds. So the image goes from no red information (0.0 red) over to a normal image (1.0 red).</p>
</div>
<div class="section" id="wave-effect">
<h2>9.4. Wave Effect<a class="headerlink" href="#wave-effect" title="Permalink to this headline">Â¶</a></h2>
<div class="admonition issues">Issues: <a href="https://github.com/qmlbook/qmlbook/issues/new?body=back-link%3A+ch09%2Findex.html%23wave-effect&labels=ch09">Create</a> | <a href="https://github.com/qmlbook/qmlbook/issues?labels=ch09&page=1&state=open">View</a></div><p>In this more complex example we will create a wave effect with the fragment shader. The wave form is based on the sinus curve and it influences the texture coordinates used for the color.</p>
<div class="highlight-qml"><div class="highlight"><pre><span class="kr">import</span> <span class="nx">QtQuick</span> <span class="mf">2.0</span>

<span class="nx">Rectangle</span> <span class="p">{</span>
    <span class="k">width:</span> <span class="mi">480</span><span class="p">;</span> <span class="k">height:</span> <span class="mi">240</span>
    <span class="k">color:</span> <span class="s1">&#39;#1e1e1e&#39;</span>

    <span class="nx">Row</span> <span class="p">{</span>
        <span class="k">anchors.centerIn:</span> <span class="nx">parent</span>
        <span class="k">spacing:</span> <span class="mi">20</span>
        <span class="nx">Image</span> <span class="p">{</span>
            <span class="kd">id: sourceImage</span>
            <span class="k">width:</span> <span class="mi">160</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
            <span class="k">source:</span> <span class="s2">&quot;assets/coastline.jpg&quot;</span>
        <span class="p">}</span>
        <span class="nx">ShaderEffect</span> <span class="p">{</span>
            <span class="k">width:</span> <span class="mi">160</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
            <span class="nx">property</span> <span class="nx">variant</span> <span class="k">source:</span> <span class="nx">sourceImage</span>
            <span class="nx">property</span> <span class="nx">real</span> <span class="k">frequency:</span> <span class="mi">8</span>
            <span class="nx">property</span> <span class="nx">real</span> <span class="k">amplitude:</span> <span class="mf">0.1</span>
            <span class="nx">property</span> <span class="nx">real</span> <span class="k">time:</span> <span class="mf">0.0</span>
            <span class="nx">NumberAnimation</span> <span class="nx">on</span> <span class="nx">time</span> <span class="p">{</span>
                <span class="k">from:</span> <span class="mi">0</span><span class="p">;</span> <span class="k">to:</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span> <span class="k">duration:</span> <span class="mi">1000</span><span class="p">;</span> <span class="k">loops:</span> <span class="nx">Animation</span><span class="p">.</span><span class="nx">Infinite</span>
            <span class="p">}</span>

            <span class="k">fragmentShader:</span> <span class="s2">&quot;</span>
<span class="s2">                varying highp vec2 qt_TexCoord0;</span>
<span class="s2">                uniform sampler2D source;</span>
<span class="s2">                uniform lowp float qt_Opacity;</span>
<span class="s2">                uniform highp float frequency;</span>
<span class="s2">                uniform highp float amplitude;</span>
<span class="s2">                uniform highp float time;</span>
<span class="s2">                void main() {</span>
<span class="s2">                    highp vec2 pulse = sin(time - frequency * qt_TexCoord0);</span>
<span class="s2">                    highp vec2 coord = qt_TexCoord0 + amplitude * vec2(pulse.x, -pulse.x);</span>
<span class="s2">                    gl_FragColor = texture2D(source, coord) * qt_Opacity;</span>
<span class="s2">                }&quot;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The wave calculation is based on a pulse and the texture coordinate manipulation. The pulse equation gives us a sine wave depending on the current time and the used texture coordinate:</p>
<div class="highlight-qml"><div class="highlight"><pre><span class="nx">highp</span> <span class="nx">vec2</span> <span class="nx">pulse</span> <span class="o">=</span> <span class="nx">sin</span><span class="p">(</span><span class="nx">time</span> <span class="o">-</span> <span class="nx">frequency</span> <span class="o">*</span> <span class="nx">qt_TexCoord0</span><span class="p">);</span>
</pre></div>
</div>
<p>Without the time factor we would just have a distortion but not a traveling distortion, like waves are.</p>
<p>For the color we use the color at a different texture coordinate:</p>
<div class="highlight-qml"><div class="highlight"><pre><span class="nx">highp</span> <span class="nx">vec2</span> <span class="nx">coord</span> <span class="o">=</span> <span class="nx">qt_TexCoord0</span> <span class="o">+</span> <span class="nx">amplitude</span> <span class="o">*</span> <span class="nx">vec2</span><span class="p">(</span><span class="nx">pulse</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="o">-</span><span class="nx">pulse</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
</pre></div>
</div>
<p>The texture coordinate is influences by our pulse x-value. The result of this is a moving wave.</p>
<img alt="../_images/wave.png" src="../_images/wave.png" />
<p>Also if we haven&#8217;t moved pixels in this fragment shader the effect would look at first like a job for a vertex shader.</p>
</div>
<div class="section" id="vertex-shader">
<h2>9.5. Vertex Shader<a class="headerlink" href="#vertex-shader" title="Permalink to this headline">Â¶</a></h2>
<div class="admonition issues">Issues: <a href="https://github.com/qmlbook/qmlbook/issues/new?body=back-link%3A+ch09%2Findex.html%23vertex-shader&labels=ch09">Create</a> | <a href="https://github.com/qmlbook/qmlbook/issues?labels=ch09&page=1&state=open">View</a></div><p>The vertex shader can be used to manipulated the vertexes provided by the shader effect. In normal cases the shader effect has 4 vertexes (top-left, top-right, bottom-left and bottom-right). Each vertex reported is from type vec4. To visualize the vertex shader we will program a genie effect. This effect is often used to let a rectangular window area vanish into one point.</p>
<img alt="../_images/genieeffect.png" src="../_images/genieeffect.png" />
<p class="rubric">Setting up the scene</p>
<p>First we will setup our scene again.</p>
<div class="highlight-qml"><div class="highlight"><pre><span class="kr">import</span> <span class="nx">QtQuick</span> <span class="mf">2.0</span>

<span class="nx">Rectangle</span> <span class="p">{</span>
    <span class="k">width:</span> <span class="mi">480</span><span class="p">;</span> <span class="k">height:</span> <span class="mi">240</span>
    <span class="k">color:</span> <span class="s1">&#39;#1e1e1e&#39;</span>

    <span class="nx">Image</span> <span class="p">{</span>
        <span class="kd">id: sourceImage</span>
        <span class="k">width:</span> <span class="mi">160</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
        <span class="k">source:</span> <span class="s2">&quot;assets/lighthouse.jpg&quot;</span>
        <span class="k">visible:</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="nx">Rectangle</span> <span class="p">{</span>
        <span class="k">width:</span> <span class="mi">160</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
        <span class="k">anchors.centerIn:</span> <span class="nx">parent</span>
        <span class="k">color:</span> <span class="s1">&#39;#333333&#39;</span>
    <span class="p">}</span>
    <span class="nx">ShaderEffect</span> <span class="p">{</span>
        <span class="kd">id: genieEffect</span>
        <span class="k">width:</span> <span class="mi">160</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
        <span class="k">anchors.centerIn:</span> <span class="nx">parent</span>
        <span class="nx">property</span> <span class="nx">variant</span> <span class="k">source:</span> <span class="nx">sourceImage</span>
        <span class="nx">property</span> <span class="nx">bool</span> <span class="k">minimized:</span> <span class="kc">false</span>
        <span class="nx">MouseArea</span> <span class="p">{</span>
            <span class="k">anchors.fill:</span> <span class="nx">parent</span>
            <span class="k">onClicked:</span> <span class="nx">genieEffect</span><span class="p">.</span><span class="nx">minimized</span> <span class="o">=</span> <span class="o">!</span><span class="nx">genieEffect</span><span class="p">.</span><span class="nx">minimized</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This provides as a scene with a dark background and a shader effect using an image as the source texture. The original image is not visible on the image produced by our genie effect. Additional we added a dark rectangle on the same geometry as the shader effect so we can better detect where we need to click to revert the effect.</p>
<img alt="../_images/geniescene.png" src="../_images/geniescene.png" />
<p>The effect is triggered by clicking on the image, this is defined by the mouse area covering the effect. In the <em>onClicked</em> handler we toggle the custom boolean property <em>minimized</em>. We will use this property later to toggle the effect.</p>
<p class="rubric">Minimize and normalize</p>
<p>After we have setup the scene, we define a property of type real called <em>minimize</em>, the property will contain the current value of our minimization. The value will vary from 0.0 to 1.0 and is controlled by a sequential animation.</p>
<div class="highlight-qml"><div class="highlight"><pre>        <span class="nx">property</span> <span class="nx">real</span> <span class="k">minimize:</span> <span class="mf">0.0</span>

        <span class="nx">SequentialAnimation</span> <span class="nx">on</span> <span class="nx">minimize</span> <span class="p">{</span>
            <span class="kd">id: animMinimize</span>
            <span class="k">running:</span> <span class="nx">genieEffect</span><span class="p">.</span><span class="nx">minimized</span>
            <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">300</span> <span class="p">}</span>
            <span class="nx">NumberAnimation</span> <span class="p">{</span> <span class="k">to:</span> <span class="mi">1</span><span class="p">;</span> <span class="k">duration:</span> <span class="mi">700</span><span class="p">;</span> <span class="k">easing.type:</span> <span class="nx">Easing</span><span class="p">.</span><span class="nx">InOutSine</span> <span class="p">}</span>
            <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">1000</span> <span class="p">}</span>
        <span class="p">}</span>

        <span class="nx">SequentialAnimation</span> <span class="nx">on</span> <span class="nx">minimize</span> <span class="p">{</span>
            <span class="kd">id: animNormalize</span>
            <span class="k">running:</span> <span class="o">!</span><span class="nx">genieEffect</span><span class="p">.</span><span class="nx">minimized</span>
            <span class="nx">NumberAnimation</span> <span class="p">{</span> <span class="k">to:</span> <span class="mi">0</span><span class="p">;</span> <span class="k">duration:</span> <span class="mi">700</span><span class="p">;</span> <span class="k">easing.type:</span> <span class="nx">Easing</span><span class="p">.</span><span class="nx">InOutSine</span> <span class="p">}</span>
            <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">1300</span> <span class="p">}</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>The animation is triggered by the togling of the <em>minimized</em> property. Now that we have setup all our surroundings we finally can look at our vertex shader.</p>
<div class="highlight-qml"><div class="highlight"><pre>        <span class="k">vertexShader:</span> <span class="s2">&quot;</span>
<span class="s2">            uniform highp mat4 qt_Matrix;</span>
<span class="s2">            attribute highp vec4 qt_Vertex;</span>
<span class="s2">            attribute highp vec2 qt_MultiTexCoord0;</span>
<span class="s2">            varying highp vec2 qt_TexCoord0;</span>
<span class="s2">            uniform highp float minimize;</span>
<span class="s2">            uniform highp float width;</span>
<span class="s2">            uniform highp float height;</span>
<span class="s2">            void main() {</span>
<span class="s2">                qt_TexCoord0 = qt_MultiTexCoord0;</span>
<span class="s2">                highp vec4 pos = qt_Vertex;</span>
<span class="s2">                pos.y = mix(qt_Vertex.y, height, minimize);</span>
<span class="s2">                pos.x = mix(qt_Vertex.x, width, minimize);</span>
<span class="s2">                gl_Position = qt_Matrix * pos;</span>
<span class="s2">            }&quot;</span>
</pre></div>
</div>
<p>The vertex shader is called for each vertex so four times, in our case. The default qt defined parameters are provided, like <em>qt_Matrix</em>, <em>qt_Vertex</em>, <em>qt_MultiTexCoord0</em>, <em>qt_TexCoord0</em>. We have discussed the variable already earlier. Additional we link the <em>minimize</em>, <em>width</em> and <em>height</em> variables from our shader effect into our vertex shader code. In the main function we store the current texture coordinate in our <em>qt_TexCoord0</em> to make it available to the fragment shader. Now we copy the current position and modify the x and y position of the vertex:</p>
<div class="highlight-qml"><div class="highlight"><pre><span class="nx">highp</span> <span class="nx">vec4</span> <span class="nx">pos</span> <span class="o">=</span> <span class="nx">qt_Vertex</span><span class="p">;</span>
<span class="nx">pos</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">mix</span><span class="p">(</span><span class="nx">qt_Vertex</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="nx">height</span><span class="p">,</span> <span class="nx">minimize</span><span class="p">);</span>
<span class="nx">pos</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">mix</span><span class="p">(</span><span class="nx">qt_Vertex</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">width</span><span class="p">,</span> <span class="nx">minimize</span><span class="p">);</span>
</pre></div>
</div>
<p>The <em>mix(...)</em> function provides a linear interpolation between the first 2 parameters on the point (0.0-1.0) provided by the 3rd parameter. So in our case we interpolate for y between the current y position and the hight based on the current minimize value, similar for x. Bear in mind the minimize value is animated by our sequential animation and travels from 0.0 to 1.0 (or vice versa).</p>
<img alt="../_images/genieminimize.png" src="../_images/genieminimize.png" />
<p>The resulting effect is not really the genie effect but is already a great step towards it.</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">better explanation, maybe draw the 4 vertexes and their interpolation</p>
</div>
<p class="rubric">Primitive Bending</p>
<p>So minimized the x and y components of our vertexes. Now we would like to slightly modify the x manipulation and make it depending of the current y value. The needed changes are pretty small. The y-position is calculated as before. The interpolation of the x-position depends now on the vertexes y-position:</p>
<div class="highlight-qml"><div class="highlight"><pre><span class="nx">highp</span> <span class="kr">float</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">pos</span><span class="p">.</span><span class="nx">y</span> <span class="o">/</span> <span class="nx">height</span><span class="p">;</span>
<span class="nx">pos</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">mix</span><span class="p">(</span><span class="nx">qt_Vertex</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">width</span><span class="p">,</span> <span class="nx">t</span> <span class="o">*</span> <span class="nx">minimize</span><span class="p">);</span>
</pre></div>
</div>
<p>This results into an x-position tending towards the width when the y-position is larger. In other words the upper 2 vertexes are not affect ed at all as they have an y-position of 0 and the lower two vertexes x-positions both bend towards the width, so they bend towards the same x-position.</p>
<img alt="../_images/geniebending.png" src="../_images/geniebending.png" />
<div class="highlight-qml"><div class="highlight"><pre>import QtQuick 2.0

Rectangle {
    width: 480; height: 240
    color: &#39;#1e1e1e&#39;

    Image {
        id: sourceImage
        width: 160; height: width
        source: &quot;assets/lighthouse.jpg&quot;
        visible: false
    }
    Rectangle {
        width: 160; height: width
        anchors.centerIn: parent
        color: &#39;#333333&#39;
    }
    ShaderEffect {
        id: genieEffect
        width: 160; height: width
        anchors.centerIn: parent
        property variant source: sourceImage
        property real minimize: 0.0
        property bool minimized: false


        SequentialAnimation on minimize {
            id: animMinimize
            running: genieEffect.minimized
            PauseAnimation { duration: 300 }
            NumberAnimation { to: 1; duration: 700; easing.type: Easing.InOutSine }
            PauseAnimation { duration: 1000 }
        }

        SequentialAnimation on minimize {
            id: animNormalize
            running: !genieEffect.minimized
            NumberAnimation { to: 0; duration: 700; easing.type: Easing.InOutSine }
            PauseAnimation { duration: 1300 }
        }


        vertexShader: &quot;
            uniform highp mat4 qt_Matrix;
            uniform highp float minimize;
            uniform highp float height;
            uniform highp float width;
            attribute highp vec4 qt_Vertex;
            attribute highp vec2 qt_MultiTexCoord0;
            varying highp vec2 qt_TexCoord0;
            void main() {
                qt_TexCoord0 = qt_MultiTexCoord0;
                // M1&gt;&gt;
                highp vec4 pos = qt_Vertex;
                pos.y = mix(qt_Vertex.y, height, minimize);
                highp float t = pos.y / height;
                pos.x = mix(qt_Vertex.x, width, t * minimize);
                gl_Position = qt_Matrix * pos;
</pre></div>
</div>
<p class="rubric">Better Bending</p>
<p>As the bending is not really satisfying currently we will add several parts to improve the situation.
First we enhance our animation to support an own bending property. This is necessary as the bending should happen immediately and the y-minimization should be delayed shortly. Both animation have in the sum the same duration (300+700+1000 and 700+1300).</p>
<div class="highlight-qml"><div class="highlight"><pre>        <span class="nx">property</span> <span class="nx">real</span> <span class="k">bend:</span> <span class="mf">0.0</span>
        <span class="nx">property</span> <span class="nx">bool</span> <span class="k">minimized:</span> <span class="kc">false</span>


        <span class="c1">// change to parallel animation</span>
        <span class="nx">ParallelAnimation</span> <span class="p">{</span>
            <span class="kd">id: animMinimize</span>
            <span class="k">running:</span> <span class="nx">genieEffect</span><span class="p">.</span><span class="nx">minimized</span>
            <span class="nx">SequentialAnimation</span> <span class="p">{</span>
                <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">300</span> <span class="p">}</span>
                <span class="nx">NumberAnimation</span> <span class="p">{</span>
                    <span class="k">target:</span> <span class="nx">genieEffect</span><span class="p">;</span> <span class="k">property:</span> <span class="s1">&#39;minimize&#39;</span><span class="p">;</span>
                    <span class="k">to:</span> <span class="mi">1</span><span class="p">;</span> <span class="k">duration:</span> <span class="mi">700</span><span class="p">;</span>
                    <span class="k">easing.type:</span> <span class="nx">Easing</span><span class="p">.</span><span class="nx">InOutSine</span>
                <span class="p">}</span>
                <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">1000</span> <span class="p">}</span>
            <span class="p">}</span>
            <span class="c1">// adding bend animation</span>
            <span class="nx">SequentialAnimation</span> <span class="p">{</span>
                <span class="nx">NumberAnimation</span> <span class="p">{</span>
                    <span class="k">target:</span> <span class="nx">genieEffect</span><span class="p">;</span> <span class="k">property:</span> <span class="s1">&#39;bend&#39;</span>
                    <span class="k">to:</span> <span class="mi">1</span><span class="p">;</span> <span class="k">duration:</span> <span class="mi">700</span><span class="p">;</span>
                    <span class="k">easing.type:</span> <span class="nx">Easing</span><span class="p">.</span><span class="nx">InOutSine</span> <span class="p">}</span>
                <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">1300</span> <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>Additional to make the bending a smooth curve the y-effect on the x-position is not modified by a curved function from 0..1 and the <tt class="docutils literal"><span class="pre">pos.x</span></tt> depends now on the new bend property animation:</p>
<div class="highlight-qml"><div class="highlight"><pre><span class="nx">highp</span> <span class="kr">float</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">pos</span><span class="p">.</span><span class="nx">y</span> <span class="o">/</span> <span class="nx">height</span><span class="p">;</span>
<span class="nx">t</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="nx">t</span><span class="p">)</span> <span class="o">*</span> <span class="nx">t</span> <span class="o">*</span> <span class="nx">t</span><span class="p">;</span>
<span class="nx">pos</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">mix</span><span class="p">(</span><span class="nx">qt_Vertex</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">width</span><span class="p">,</span> <span class="nx">t</span> <span class="o">*</span> <span class="nx">bend</span><span class="p">);</span>
</pre></div>
</div>
<p>The curve starts smooth at the 0.0 value, grows then and stops smoothly towards the 1.0 value. Here is a plot of the function in the specified range. For us only the range from 0..1 is from interest.</p>
<img alt="../_images/curve.png" src="../_images/curve.png" />
<p>The most visual change is by increasing our amount of vertex points. The vertex points used can be increased by using a mesh:</p>
<div class="highlight-qml"><div class="highlight"><pre><span class="k">mesh:</span> <span class="nx">GridMesh</span> <span class="p">{</span> <span class="k">resolution:</span> <span class="nx">Qt</span><span class="p">.</span><span class="nx">size</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>The shader effect now has an equality distributed grid of 16x16 vertexes instead of the 2x2 vertexes used before. This makes the interpolation between the vertexes look much smoother.</p>
<img alt="../_images/geniesmoothbending.png" src="../_images/geniesmoothbending.png" />
<p>You can see also the influence of the curve being used, as the bending smoothes at the end nicely. This is where the bending has the strongest effect.</p>
<p class="rubric">Choosing Sides</p>
<p>As a final enhancement we want to be able to switch sides. The side is towards which point the genie effect vanishes. Till now it vanishes always towards the width. By adding a <em>side</em> property we are able to modify the point between 0 and width.</p>
<div class="highlight-js"><div class="highlight"><pre><span class="nx">ShaderEffect</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="nx">property</span> <span class="nx">real</span> <span class="nx">side</span><span class="o">:</span> <span class="mf">0.5</span>

    <span class="nx">vertexShader</span><span class="o">:</span> <span class="s2">&quot;</span>
<span class="s2">        ...</span>
<span class="s2">        uniform highp float side;</span>
<span class="s2">        ...</span>
<span class="s2">        pos.x = mix(qt_Vertex.x, side * width, t * bend);</span>
<span class="s2">    &quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<img alt="../_images/geniehalfside.png" src="../_images/geniehalfside.png" />
<p class="rubric">Packaging</p>
<p>The last thing to-do is package our effect nicely. For this we extract our genie effect code into an own component called <em>GenieEffect</em>. It has the shader effect as the root element. We removed the mouse area as this should not be inside the component as the triggering of the effect can be toggled by the <em>minimized</em> property.</p>
<div class="highlight-qml"><div class="highlight"><pre><span class="kr">import</span> <span class="nx">QtQuick</span> <span class="mf">2.0</span>

<span class="nx">ShaderEffect</span> <span class="p">{</span>
    <span class="kd">id: genieEffect</span>
    <span class="k">width:</span> <span class="mi">160</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
    <span class="k">anchors.centerIn:</span> <span class="nx">parent</span>
    <span class="nx">property</span> <span class="nx">variant</span> <span class="nx">source</span>
    <span class="k">mesh:</span> <span class="nx">GridMesh</span> <span class="p">{</span> <span class="k">resolution:</span> <span class="nx">Qt</span><span class="p">.</span><span class="nx">size</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="p">}</span>
    <span class="nx">property</span> <span class="nx">real</span> <span class="k">minimize:</span> <span class="mf">0.0</span>
    <span class="nx">property</span> <span class="nx">real</span> <span class="k">bend:</span> <span class="mf">0.0</span>
    <span class="nx">property</span> <span class="nx">bool</span> <span class="k">minimized:</span> <span class="kc">false</span>
    <span class="nx">property</span> <span class="nx">real</span> <span class="k">side:</span> <span class="mf">1.0</span>


    <span class="nx">ParallelAnimation</span> <span class="p">{</span>
        <span class="kd">id: animMinimize</span>
        <span class="k">running:</span> <span class="nx">genieEffect</span><span class="p">.</span><span class="nx">minimized</span>
        <span class="nx">SequentialAnimation</span> <span class="p">{</span>
            <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">300</span> <span class="p">}</span>
            <span class="nx">NumberAnimation</span> <span class="p">{</span>
                <span class="k">target:</span> <span class="nx">genieEffect</span><span class="p">;</span> <span class="k">property:</span> <span class="s1">&#39;minimize&#39;</span><span class="p">;</span>
                <span class="k">to:</span> <span class="mi">1</span><span class="p">;</span> <span class="k">duration:</span> <span class="mi">700</span><span class="p">;</span>
                <span class="k">easing.type:</span> <span class="nx">Easing</span><span class="p">.</span><span class="nx">InOutSine</span>
            <span class="p">}</span>
            <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">1000</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">SequentialAnimation</span> <span class="p">{</span>
            <span class="nx">NumberAnimation</span> <span class="p">{</span>
                <span class="k">target:</span> <span class="nx">genieEffect</span><span class="p">;</span> <span class="k">property:</span> <span class="s1">&#39;bend&#39;</span>
                <span class="k">to:</span> <span class="mi">1</span><span class="p">;</span> <span class="k">duration:</span> <span class="mi">700</span><span class="p">;</span>
                <span class="k">easing.type:</span> <span class="nx">Easing</span><span class="p">.</span><span class="nx">InOutSine</span> <span class="p">}</span>
            <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">1300</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">ParallelAnimation</span> <span class="p">{</span>
        <span class="kd">id: animNormalize</span>
        <span class="k">running:</span> <span class="o">!</span><span class="nx">genieEffect</span><span class="p">.</span><span class="nx">minimized</span>
        <span class="nx">SequentialAnimation</span> <span class="p">{</span>
            <span class="nx">NumberAnimation</span> <span class="p">{</span>
                <span class="k">target:</span> <span class="nx">genieEffect</span><span class="p">;</span> <span class="k">property:</span> <span class="s1">&#39;minimize&#39;</span><span class="p">;</span>
                <span class="k">to:</span> <span class="mi">0</span><span class="p">;</span> <span class="k">duration:</span> <span class="mi">700</span><span class="p">;</span>
                <span class="k">easing.type:</span> <span class="nx">Easing</span><span class="p">.</span><span class="nx">InOutSine</span>
            <span class="p">}</span>
            <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">1300</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">SequentialAnimation</span> <span class="p">{</span>
            <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">300</span> <span class="p">}</span>
            <span class="nx">NumberAnimation</span> <span class="p">{</span>
                <span class="k">target:</span> <span class="nx">genieEffect</span><span class="p">;</span> <span class="k">property:</span> <span class="s1">&#39;bend&#39;</span>
                <span class="k">to:</span> <span class="mi">0</span><span class="p">;</span> <span class="k">duration:</span> <span class="mi">700</span><span class="p">;</span>
                <span class="k">easing.type:</span> <span class="nx">Easing</span><span class="p">.</span><span class="nx">InOutSine</span> <span class="p">}</span>
            <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">1000</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">vertexShader:</span> <span class="s2">&quot;</span>
<span class="s2">        uniform highp mat4 qt_Matrix;</span>
<span class="s2">        attribute highp vec4 qt_Vertex;</span>
<span class="s2">        attribute highp vec2 qt_MultiTexCoord0;</span>
<span class="s2">        uniform highp float height;</span>
<span class="s2">        uniform highp float width;</span>
<span class="s2">        uniform highp float minimize;</span>
<span class="s2">        uniform highp float bend;</span>
<span class="s2">        uniform highp float side;</span>
<span class="s2">        varying highp vec2 qt_TexCoord0;</span>
<span class="s2">        void main() {</span>
<span class="s2">            qt_TexCoord0 = qt_MultiTexCoord0;</span>
<span class="s2">            highp vec4 pos = qt_Vertex;</span>
<span class="s2">            pos.y = mix(qt_Vertex.y, height, minimize);</span>
<span class="s2">            highp float t = pos.y / height;</span>
<span class="s2">            t = (3.0 - 2.0 * t) * t * t;</span>
<span class="s2">            pos.x = mix(qt_Vertex.x, side * width, t * bend);</span>
<span class="s2">            gl_Position = qt_Matrix * pos;</span>
<span class="s2">        }&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You can use now the effect simply like this:</p>
<div class="highlight-qml"><div class="highlight"><pre><span class="kr">import</span> <span class="nx">QtQuick</span> <span class="mf">2.0</span>

<span class="nx">Rectangle</span> <span class="p">{</span>
    <span class="k">width:</span> <span class="mi">480</span><span class="p">;</span> <span class="k">height:</span> <span class="mi">240</span>
    <span class="k">color:</span> <span class="s1">&#39;#1e1e1e&#39;</span>

    <span class="nx">GenieEffect</span> <span class="p">{</span>
        <span class="k">source:</span> <span class="nx">Image</span> <span class="p">{</span> <span class="k">source:</span> <span class="s1">&#39;assets/lighthouse.jpg&#39;</span> <span class="p">}</span>
        <span class="nx">MouseArea</span> <span class="p">{</span>
            <span class="k">anchors.fill:</span> <span class="nx">parent</span>
            <span class="k">onClicked:</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">minimized</span> <span class="o">=</span> <span class="o">!</span><span class="nx">parent</span><span class="p">.</span><span class="nx">minimized</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We have simplified the code by removing our background rectangle and we assigned the image directly to the effect, instead of loading it inside a standalone image element.</p>
</div>
<div class="section" id="curtain-effect">
<h2>9.6. Curtain Effect<a class="headerlink" href="#curtain-effect" title="Permalink to this headline">Â¶</a></h2>
<div class="admonition issues">Issues: <a href="https://github.com/qmlbook/qmlbook/issues/new?body=back-link%3A+ch09%2Findex.html%23curtain-effect&labels=ch09">Create</a> | <a href="https://github.com/qmlbook/qmlbook/issues?labels=ch09&page=1&state=open">View</a></div><p>In the last example for custom shader effects I would like to bring you the curtain effect. This effect was published first in May 2011 as part of <a class="reference external" href="http://labs.qt.nokia.com/2011/05/03/qml-shadereffectitem-on-qgraphicsview/">Qt labs for shader effects</a>.</p>
<img alt="../_images/curtain.png" src="../_images/curtain.png" />
<p>At that time I really loved these effects and the curtain effect was my favorite out of them. I just love how the curtain opens and hide the background object.</p>
<p>I took the code and adapted it towards Qt5, which was straightforward. Also O did some simplifications to be able to use it better for a showcase. So if you are interested in the full example, please visit the labs blog.</p>
<p>Just a little bot for the background, the curtain is actually an image called <em>fabric.jpg</em> and it is the source for a shader effect. The effect uses the vertex shader to swing the curtain and uses the fragment shader to provide some shades. Here is a simple diagram to make you hopefully better understand the code.</p>
<img alt="../_images/curtain_diagram.png" src="../_images/curtain_diagram.png" />
<p>The waved shades of the curtain are computed through a sin curve with 7 up/downs (7*PI=21.99...) on the width of the curtain. The other important part is the swing. The <em>topWidth</em> of the curtain is animated when the curtain is opened or closed. The <em>bottomWidth</em> follows the <em>topWidth</em> with a <em>SpringAnimation</em>. By this we create the effect of the swinging bottom part of the curtain. The calculated <em>swing</em> provides the strength of this swing interpolated over the y-component of the vertexes.</p>
<p>The curtain effect is located in the <tt class="docutils literal"><span class="pre">CurtainEffect.qml</span></tt> component where the fabric image act as the texture source. There is nothing new on the use of shaders here, only a different way to manipulate the <em>gl_Position</em> in the vertex shader and the <em>gl_FragColor</em> in the fragment shader.</p>
<div class="highlight-qml"><div class="highlight"><pre><span class="kr">import</span> <span class="nx">QtQuick</span> <span class="mf">2.0</span>

<span class="nx">ShaderEffect</span> <span class="p">{</span>
    <span class="k">anchors.fill:</span> <span class="nx">parent</span>

    <span class="k">mesh:</span> <span class="nx">GridMesh</span> <span class="p">{</span>
        <span class="k">resolution:</span> <span class="nx">Qt</span><span class="p">.</span><span class="nx">size</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">property</span> <span class="nx">real</span> <span class="k">topWidth:</span> <span class="nx">open</span><span class="o">?</span><span class="k">width:</span><span class="mi">20</span>
    <span class="nx">property</span> <span class="nx">real</span> <span class="k">bottomWidth:</span> <span class="nx">topWidth</span>
    <span class="nx">property</span> <span class="nx">real</span> <span class="k">amplitude:</span> <span class="mf">0.1</span>
    <span class="nx">property</span> <span class="nx">bool</span> <span class="k">open:</span> <span class="kc">false</span>
    <span class="nx">property</span> <span class="nx">variant</span> <span class="k">source:</span> <span class="nx">effectSource</span>

    <span class="nx">Behavior</span> <span class="nx">on</span> <span class="nx">bottomWidth</span> <span class="p">{</span>
        <span class="nx">SpringAnimation</span> <span class="p">{</span>
            <span class="k">easing.type:</span> <span class="nx">Easing</span><span class="p">.</span><span class="nx">OutElastic</span><span class="p">;</span>
            <span class="k">velocity:</span> <span class="mi">250</span><span class="p">;</span> <span class="k">mass:</span> <span class="mf">1.5</span><span class="p">;</span>
            <span class="k">spring:</span> <span class="mf">0.5</span><span class="p">;</span> <span class="k">damping:</span> <span class="mf">0.05</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">Behavior</span> <span class="nx">on</span> <span class="nx">topWidth</span> <span class="p">{</span>
        <span class="nx">NumberAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">1000</span> <span class="p">}</span>
    <span class="p">}</span>


    <span class="nx">ShaderEffectSource</span> <span class="p">{</span>
        <span class="kd">id: effectSource</span>
        <span class="k">sourceItem:</span> <span class="nx">effectImage</span><span class="p">;</span>
        <span class="k">hideSource:</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="nx">Image</span> <span class="p">{</span>
        <span class="kd">id: effectImage</span>
        <span class="k">anchors.fill:</span> <span class="nx">parent</span>
        <span class="k">source:</span> <span class="s2">&quot;assets/fabric.jpg&quot;</span>
        <span class="k">fillMode:</span> <span class="nx">Image</span><span class="p">.</span><span class="nx">Tile</span>
    <span class="p">}</span>

    <span class="k">vertexShader:</span> <span class="s2">&quot;</span>
<span class="s2">        attribute highp vec4 qt_Vertex;</span>
<span class="s2">        attribute highp vec2 qt_MultiTexCoord0;</span>
<span class="s2">        uniform highp mat4 qt_Matrix;</span>
<span class="s2">        varying highp vec2 qt_TexCoord0;</span>
<span class="s2">        varying lowp float shade;</span>

<span class="s2">        uniform highp float topWidth;</span>
<span class="s2">        uniform highp float bottomWidth;</span>
<span class="s2">        uniform highp float width;</span>
<span class="s2">        uniform highp float height;</span>
<span class="s2">        uniform highp float amplitude;</span>

<span class="s2">        void main() {</span>
<span class="s2">            qt_TexCoord0 = qt_MultiTexCoord0;</span>

<span class="s2">            highp vec4 shift = vec4(0.0, 0.0, 0.0, 0.0);</span>
<span class="s2">            highp float swing = (topWidth - bottomWidth) * (qt_Vertex.y / height);</span>
<span class="s2">            shift.x = qt_Vertex.x * (width - topWidth + swing) / width;</span>

<span class="s2">            shade = sin(21.9911486 * qt_Vertex.x / width);</span>
<span class="s2">            shift.y = amplitude * (width - topWidth + swing) * shade;</span>

<span class="s2">            gl_Position = qt_Matrix * (qt_Vertex - shift);</span>

<span class="s2">            shade = 0.2 * (2.0 - shade ) * ((width - topWidth + swing) / width);</span>
<span class="s2">        }&quot;</span>

    <span class="k">fragmentShader:</span> <span class="s2">&quot;</span>
<span class="s2">        uniform sampler2D source;</span>
<span class="s2">        varying highp vec2 qt_TexCoord0;</span>
<span class="s2">        varying lowp float shade;</span>
<span class="s2">        void main() {</span>
<span class="s2">            highp vec4 color = texture2D(source, qt_TexCoord0);</span>
<span class="s2">            color.rgb *= 1.0 - shade;</span>
<span class="s2">            gl_FragColor = color;</span>
<span class="s2">        }&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The effect is used in the <tt class="docutils literal"><span class="pre">curtaindemo.qml</span></tt> file.</p>
<div class="highlight-qml"><div class="highlight"><pre><span class="kr">import</span> <span class="nx">QtQuick</span> <span class="mf">2.0</span>

<span class="nx">Rectangle</span> <span class="p">{</span>
    <span class="kd">id: root</span>
    <span class="k">width:</span> <span class="mi">480</span><span class="p">;</span> <span class="k">height:</span> <span class="mi">240</span>
    <span class="k">color:</span> <span class="s1">&#39;#1e1e1e&#39;</span>

    <span class="nx">Image</span> <span class="p">{</span>
        <span class="k">anchors.centerIn:</span> <span class="nx">parent</span>
        <span class="k">source:</span> <span class="s1">&#39;assets/wiesn.jpg&#39;</span>
    <span class="p">}</span>

    <span class="nx">CurtainEffect</span> <span class="p">{</span>
        <span class="kd">id: curtain</span>
        <span class="k">anchors.fill:</span> <span class="nx">parent</span>
    <span class="p">}</span>

    <span class="nx">MouseArea</span> <span class="p">{</span>
        <span class="k">anchors.fill:</span> <span class="nx">parent</span>
        <span class="k">onClicked:</span> <span class="nx">curtain</span><span class="p">.</span><span class="nx">open</span> <span class="o">=</span> <span class="o">!</span><span class="nx">curtain</span><span class="p">.</span><span class="nx">open</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The curtain is opened through a custom <em>open</em> property on the curtain effect. We use a <em>MouseArea</em> to trigger the opening and closing of the curtain.</p>
</div>
<div class="section" id="qt-graphicseffect-library">
<h2>9.7. Qt GraphicsEffect Library<a class="headerlink" href="#qt-graphicseffect-library" title="Permalink to this headline">Â¶</a></h2>
<div class="admonition issues">Issues: <a href="https://github.com/qmlbook/qmlbook/issues/new?body=back-link%3A+ch09%2Findex.html%23qt-graphicseffect-library&labels=ch09">Create</a> | <a href="https://github.com/qmlbook/qmlbook/issues?labels=ch09&page=1&state=open">View</a></div><p>The graphics effect library is a collection of shader effects. Ready made by the Qt developers. It&#8217;s a great tool-set to be used in your application but also a great source to learn how to build shaders.</p>
<p>The graphics effects library comes with a so called manual testbed which is a great tool to interactively discover the different effects.</p>
<p>The testbed is located under <tt class="docutils literal"><span class="pre">$QTDIR/qtgraphicaleffects/tests/manual/testbed</span></tt>.</p>
<img alt="../_images/graphicseffectstestbed.png" src="../_images/graphicseffectstestbed.png" />
<p>The effects library contains ca 20 effects. A list of the effect and a short description can be found below.</p>
<p class="rubric">Graphics Effects List</p>
<table border="1" class="docutils">
<caption>Graphics Effects List</caption>
<colgroup>
<col width="27%" />
<col width="18%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Category</th>
<th class="head">Effect</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Blend</td>
<td><em>Blend</em></td>
<td>merges two source items by using a blend mode</td>
</tr>
<tr class="row-odd"><td>Color</td>
<td><em>BrightnessContrast</em></td>
<td>adjusts brightness and contrast</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td><em>Colorize</em></td>
<td>sets color in the HSL color space</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td><em>ColorOverlay</em></td>
<td>applies a color layer</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td><em>Desaturate</em></td>
<td>reduces color saturation</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td><em>GammaAdjust</em></td>
<td>adjusts luminance</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td><em>HueSaturation</em></td>
<td>adjusts colors in the HSL color space</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td><em>LevelAdjust</em></td>
<td>adjusts colors in the RGB color space</td>
</tr>
<tr class="row-even"><td>Gradient</td>
<td><em>ConicalGradient</em></td>
<td>draws a conical gradient</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td><em>LinearGradient</em></td>
<td>draws a linear gradient</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td><em>RadialGradient</em></td>
<td>draws a radial gradient</td>
</tr>
<tr class="row-odd"><td>Distortion</td>
<td><em>Displace</em></td>
<td>moves the pixels of the source item according to the specified displacement source</td>
</tr>
<tr class="row-even"><td>Drop Shadow</td>
<td><em>DropShadow</em></td>
<td>draws a drop shadow</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td><em>InnerShadow</em></td>
<td>draws an inner shadow</td>
</tr>
<tr class="row-even"><td>Blur</td>
<td><em>FastBlur</em></td>
<td>applies a fast blur effect</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td><em>GaussianBlur</em></td>
<td>applies a higher quality blur effect</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td><em>MaskedBlur</em></td>
<td>applies a varying intensity blur effect</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td><em>RecursiveBlur</em></td>
<td>blurs repeatedly, providing a strong blur effect</td>
</tr>
<tr class="row-even"><td>Motion Blur</td>
<td><em>DirectionalBlur</em></td>
<td>applies a directional motion blur effect</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td><em>RadialBlur</em></td>
<td>applies a radial motion blur effect</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td><em>ZoomBlur</em></td>
<td>applies a zoom motion blur effect</td>
</tr>
<tr class="row-odd"><td>Glow</td>
<td><em>Glow</em></td>
<td>draws an outer glow effect</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td><em>RectangularGlow</em></td>
<td>draws a rectangular outer glow effect</td>
</tr>
<tr class="row-odd"><td>Mask</td>
<td><em>OpacityMask</em></td>
<td>masks the source item with another item</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td><em>ThresholdMask</em></td>
<td>masks the source item with another item and applies a threshold value</td>
</tr>
</tbody>
</table>
<p>Here is a example using the <em>FastBlur</em> effect from the <em>Blur</em> category:</p>
<div class="highlight-qml"><div class="highlight"><pre><span class="kr">import</span> <span class="nx">QtQuick</span> <span class="mf">2.0</span>
<span class="kr">import</span> <span class="nx">QtGraphicalEffects</span> <span class="mf">1.0</span>

<span class="nx">Rectangle</span> <span class="p">{</span>
    <span class="k">width:</span> <span class="mi">480</span><span class="p">;</span> <span class="k">height:</span> <span class="mi">240</span>
    <span class="k">color:</span> <span class="s1">&#39;#1e1e1e&#39;</span>

    <span class="nx">Row</span> <span class="p">{</span>
        <span class="k">anchors.centerIn:</span> <span class="nx">parent</span>
        <span class="k">spacing:</span> <span class="mi">16</span>

        <span class="nx">Image</span> <span class="p">{</span>
            <span class="kd">id: sourceImage</span>
            <span class="k">source:</span> <span class="s2">&quot;assets/tulips.jpg&quot;</span>
            <span class="k">width:</span> <span class="mi">200</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
            <span class="k">sourceSize:</span> <span class="nx">Qt</span><span class="p">.</span><span class="nx">size</span><span class="p">(</span><span class="nx">parent</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">height</span><span class="p">)</span>
            <span class="k">smooth:</span> <span class="kc">true</span>
        <span class="p">}</span>

        <span class="nx">FastBlur</span> <span class="p">{</span>
            <span class="k">width:</span> <span class="mi">200</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
            <span class="k">source:</span> <span class="nx">sourceImage</span>
            <span class="k">radius:</span> <span class="nx">blurred</span><span class="o">?</span><span class="mi">32</span><span class="o">:</span><span class="mi">0</span>
            <span class="nx">property</span> <span class="nx">bool</span> <span class="k">blurred:</span> <span class="kc">false</span>

            <span class="nx">Behavior</span> <span class="nx">on</span> <span class="nx">radius</span> <span class="p">{</span>
                <span class="nx">NumberAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">1000</span> <span class="p">}</span>
            <span class="p">}</span>

            <span class="nx">MouseArea</span> <span class="p">{</span>
                <span class="kd">id: area</span>
                <span class="k">anchors.fill:</span> <span class="nx">parent</span>
                <span class="k">onClicked:</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">blurred</span> <span class="o">=</span> <span class="o">!</span><span class="nx">parent</span><span class="p">.</span><span class="nx">blurred</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The image to the left is the original image. Clicking the image on the right will toggle blurred property and animated the blur radius from 0 to 32 during 1 second. The image on the left show the blurred image.</p>
<img alt="../_images/fastblur.png" src="../_images/fastblur.png" />
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2012-2014 JÃ¼rgen Bocklage-Ryannel and Johan Thelin. This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.<br/>
      Last updated on Dec 22, 2014.<br/>
    </p>
  </div>
</footer>
  </body>
</html>